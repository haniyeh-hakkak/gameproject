<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Skeleton</title>
    <script type="text/javascript" src="lib/three.js"></script>
    <script src="lib/THREEx.KeyboardState.js"></script>
    <script src="lib/cannon.js"></script>
    <script src="lib/dat.gui.min.js"></script>
    <script src="lib/CannonDebugRenderer.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>


<div id="WebGL-output">
</div>

<script type="text/javascript">
    var scene, camera, renderer;
    var cube, cube2, world;
    var directionalLight, spotLight;
    var keyboard = new THREEx.KeyboardState();
    var surfaceMesh, ballMesh, ballBody, groundBody, groundShape, cannonDebugRenderer,timeStep = 1/60;
    var shootingDirection,shootingVelocity;

    var phsyicRenderer = false;

    init();
    initCannon();
    animate();

    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 75, 15);
        camera.lookAt(scene.position);


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        var textureground = new THREE.TextureLoader().load('texture/ground-texture2.jpg');
        textureground.wrapS = THREE.RepeatWrapping;
        textureground.wrapT = THREE.RepeatWrapping;
        textureground.magFilter = THREE.LinearFilter;
        textureground.minFilter = THREE.LinearMipMapLinearFilter;


        var surfaceGeometry = new THREE.PlaneGeometry(100, 150, 1);
        var surfaceMaterial = new THREE.MeshBasicMaterial({
            color: "0xcccccc",
            side: THREE.DoubleSide,
            map: textureground
        });
        surfaceMesh = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
        surfaceMesh.rotateX(Math.PI / 2);
        //surfaceMesh.position.y = -20;
        scene.add(surfaceMesh);

        var texturewall = new THREE.TextureLoader().load('texture/images.jpg');
        texturewall.repeat.set(2,1);
        texturewall.wrapS = THREE.RepeatWrapping;
        texturewall.wrapT = THREE.RepeatWrapping;
        texturewall.magFilter = THREE.LinearFilter;
        texturewall.minFilter = THREE.LinearMipMapLinearFilter;

        var texturewall2 = new THREE.TextureLoader().load('texture/wall2.jpg');
        texturewall2.repeat.set(3,1);
        texturewall2.wrapS = THREE.RepeatWrapping;
        texturewall2.wrapT = THREE.RepeatWrapping;
        texturewall2.magFilter = THREE.LinearFilter;
        texturewall2.minFilter = THREE.LinearMipMapLinearFilter;

        var wall1Geometry = new THREE.PlaneGeometry(100, 10, 1);
        var wall1Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall});
        var wall1 = new THREE.Mesh(wall1Geometry, wall1Material);
        wall1.position.x = 0;
        wall1.position.y = 5;
        wall1.position.z = -75;
        scene.add(wall1);

        var wall2Geometry = new THREE.PlaneGeometry(100, 10, 1);
        var wall2Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall});
        var wall2 = new THREE.Mesh(wall2Geometry, wall2Material);
        wall2.position.x = 0;
        wall2.position.y = 5;
        wall2.position.z = 75;
        scene.add(wall2);


        var wall3Geometry = new THREE.PlaneGeometry(150, 10, 1);
        var wall3Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall2});
        var wall3 = new THREE.Mesh(wall3Geometry, wall3Material);
        wall3.rotateY(Math.PI / 2);
        wall3.position.x = -50;
        wall3.position.y = 5;
        wall3.position.z = 0;
        scene.add(wall3);

        var wall4Geometry = new THREE.PlaneGeometry(150, 10, 1);
        var wall4Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall2});
        var wall4 = new THREE.Mesh(wall4Geometry, wall4Material);
        wall4.rotateY(Math.PI / 2);
        wall4.position.x = 50;
        wall4.position.y = 5;
        wall4.position.z = 0;
        scene.add(wall4);


        var rocket1Geometry = new THREE.BoxGeometry(15, 7, 5);
        var rocket1Material = new THREE.MeshBasicMaterial({color: "#800000"});
        cube = new THREE.Mesh(rocket1Geometry, rocket1Material);
        cube.position.y = 5;
        cube.position.z = -70;
        scene.add(cube);

        var roket2Geometry = new THREE.BoxGeometry(15, 7, 5);
        var roket2Material = new THREE.MeshBasicMaterial({color: "#800000"});
        cube2 = new THREE.Mesh(roket2Geometry, roket2Material);
        cube2.position.y = 5;
        cube2.position.z = 70;
        scene.add(cube2);

        var textureball = new THREE.TextureLoader().load('texture/tennisball2.jpg');
        textureball.wrapS = THREE.RepeatWrapping;
        textureball.wrapT = THREE.RepeatWrapping;
        textureball.magFilter = THREE.LinearFilter;
        textureball.minFilter = THREE.LinearMipMapLinearFilter;


        var ballGeometry = new THREE.SphereGeometry(3,16,16);
        var ballMaterial = new THREE.MeshBasicMaterial({color:"#0xcccccc" , map:textureball});
        ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
        ballMesh.position.y = 5;
        scene.add(ballMesh);

        var axesHelper = new THREE.AxisHelper(4);
        axesHelper.rotateY(Math.PI * 3 / 2);
        scene.add(axesHelper);
    }

    function initCannon() {

        world = new CANNON.World();


        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;
        var solver = new CANNON.GSSolver();
        solver.iterations = 10;
        solver.tolerance = 0.1;
        world.defaultContactMaterial.contactEquationStiffness = 1e8;
        world.defaultContactMaterial.contactEquationRelaxation = 3;
        var split = true;
        if (split)
            world.solver = new CANNON.SplitSolver(solver);
        else
            world.solver = solver;
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();


        //create ground material
        var physicMaterial = new CANNON.Material("groundMaterial");
        //create contact material
        var groundContactMaterial = new CANNON.ContactMaterial(physicMaterial,physicMaterial, {
            friction : 0.02,
            restitution : 0.3

        });
        world.addContactMaterial(groundContactMaterial);



        //  ground body
        groundShape = new CANNON.Plane();
        groundBody = new CANNON.Body({mass: 0,material:physicMaterial});
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        groundBody.addShape(groundShape);
        world.add(groundBody);

        //ball body
        var ballShape = new CANNON.Sphere(3);
        ballBody = new CANNON.Body({mass: 2});
        ballBody.addShape(ballShape);
        ballBody.position.set(0,5,0);
        world.add(ballBody);



    }

    function animate() {
        if (keyboard.pressed("left") && cube.position.x > -42) {
            cube.position.x -= 1;
        } else if (keyboard.pressed("right") && cube.position.x < 42) {
            cube.position.x += 1;
        }
        if (keyboard.pressed("A") && cube2.position.x > -42) {
            cube2.position.x -= 1;
        } else if (keyboard.pressed("D") && cube2.position.x < 42) {
            cube2.position.x += 1;
        }
        updatePhysics();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

    }

    function updatePhysics() {
        world.step(timeStep);

        ballMesh.position.copy(ballBody.position);
        ballMesh.quaternion.copy(ballBody.quaternion);
    }

    function getRandom(){
        var x;
        while(1) {
            x = Math.random()*2-0.5 ;
            if(1.4<x<2 || -2<x<-1.4){
                return x;
            }
        }

    }
    function startTheGame() {

        var x = getRandom();
        var z = getRandom();

        shootingDirection = new THREE.Vector3(1,0,1);
        shootingDirection.x = getRandom();
        shootingDirection.z = getRandom();

        shootingVelocity = 45;
        ballBody.velocity.set(
            shootingDirection.x * shootingVelocity,
            shootingDirection.y * shootingVelocity,
            shootingDirection.z * shootingVelocity);
    }

    window.addEventListener("keydown",function (event) {
        if(event.keyCode == 32){
            startTheGame();
        }

    });


</script>
</body>
</html>