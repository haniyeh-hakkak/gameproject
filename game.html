<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Skeleton</title>
    <script type="text/javascript" src="lib/three.js"></script>
    <script src="lib/THREEx.KeyboardState.js"></script>
    <script src="lib/cannon.js"></script>
    <script src="lib/dat.gui.min.js"></script>
    <script src="lib/CannonDebugRenderer.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>


<div id="WebGL-output">
</div>

<script type="text/javascript">
    var scene, camera, renderer;
    var cube, cube2, ballBody, world;
    var directionalLight, spotLight;
    var keyboard = new THREEx.KeyboardState();
    var surfaceMesh, ballMesh, ballBody, groundBody, groundShape, cannonDebugRenderer,timeStep = 1/60;

    var phsyicRenderer = false;

    init();
    initCannon();
    animate();

    function init() {

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 80, 15);
        camera.lookAt(scene.position);


        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setClearColor(new THREE.Color(0x000000));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        var textureground = new THREE.TextureLoader().load('texture/ground-texture2.jpg');
        textureground.wrapS = THREE.RepeatWrapping;
        textureground.wrapT = THREE.RepeatWrapping;
        textureground.magFilter = THREE.LinearFilter;
        textureground.minFilter = THREE.LinearMipMapLinearFilter;


        var surfaceGeometry = new THREE.PlaneGeometry(100, 150, 1);
        var surfaceMaterial = new THREE.MeshBasicMaterial({
            color: "0xcccccc",
            side: THREE.DoubleSide,
            map: textureground
        });
        surfaceMesh = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
        surfaceMesh.rotateX(Math.PI / 2);
        surfaceMesh.position.y = -20;
        scene.add(surfaceMesh);

        var texturewall = new THREE.TextureLoader().load('texture/Wall Various-015.jpg');
        texturewall.wrapS = THREE.RepeatWrapping;
        texturewall.wrapT = THREE.RepeatWrapping;
        texturewall.magFilter = THREE.LinearFilter;
        texturewall.minFilter = THREE.LinearMipMapLinearFilter;

        var texturewall2 = new THREE.TextureLoader().load('texture/Various-007.jpg');
        texturewall2.repeat.set(2, 1);
        texturewall2.wrapS = THREE.RepeatWrapping;
        texturewall2.wrapT = THREE.RepeatWrapping;
        texturewall2.magFilter = THREE.LinearFilter;
        texturewall2.minFilter = THREE.LinearMipMapLinearFilter;

        var wall1Geometry = new THREE.PlaneGeometry(100, 10, 1);
        var wall1Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall});
        var wall1 = new THREE.Mesh(wall1Geometry, wall1Material);
        wall1.position.x = 0;
        wall1.position.y = -15;
        wall1.position.z = -75;
        scene.add(wall1);

        var wall2Geometry = new THREE.PlaneGeometry(100, 10, 1);
        var wall2Material = new THREE.MeshBasicMaterial({color: "#0xcccccc", side: THREE.DoubleSide, map: texturewall});
        var wall2 = new THREE.Mesh(wall2Geometry, wall2Material);
        wall2.position.x = 0;
        wall2.position.y = -15;
        wall2.position.z = 75;
        scene.add(wall2);


        var wall3Geometry = new THREE.PlaneGeometry(150, 10, 1);
        var wall3Material = new THREE.MeshBasicMaterial({color: "#808080", side: THREE.DoubleSide, map: texturewall2});
        var wall3 = new THREE.Mesh(wall3Geometry, wall3Material);
        wall3.rotateY(Math.PI / 2);
        wall3.position.x = -50;
        wall3.position.y = -15;
        wall3.position.z = 0;
        scene.add(wall3);

        var wall4Geometry = new THREE.PlaneGeometry(150, 10, 1);
        var wall4Material = new THREE.MeshBasicMaterial({color: "#808080", side: THREE.DoubleSide, map: texturewall2});
        var wall4 = new THREE.Mesh(wall4Geometry, wall4Material);
        wall4.rotateY(Math.PI / 2);
        wall4.position.x = 50;
        wall4.position.y = -15;
        wall4.position.z = 0;
        scene.add(wall4);


        var rocket1Geometry = new THREE.BoxGeometry(15, 7, 5);
        var rocket1Material = new THREE.MeshBasicMaterial({color: "#800000"});
        cube = new THREE.Mesh(rocket1Geometry, rocket1Material);
        cube.position.y = -15;
        cube.position.z = -70;
        scene.add(cube);

        var roket2Geometry = new THREE.BoxGeometry(15, 7, 5);
        var roket2Material = new THREE.MeshBasicMaterial({color: "#800000"});
        cube2 = new THREE.Mesh(roket2Geometry, roket2Material);
        cube2.position.y = -15;
        cube2.position.z = 70;
        scene.add(cube2);

        var ballGeometry = new THREE.SphereGeometry(3, 32, 32);
        var ballMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
        ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
        ballMesh.position.y = -20;
        scene.add(ballMesh);

        var axesHelper = new THREE.AxisHelper(4);
        axesHelper.rotateY(Math.PI * 3 / 2);
        scene.add(axesHelper);
    }

    function initCannon() {

        world = new CANNON.World();
        world.gravity.set(0, -9.87, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 20;



        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRelaxation = 4;

//  ground body
        groundShape = new CANNON.Plane();
        groundBody = new CANNON.Body({mass: 0});
        groundBody.addShape(groundShape);
        world.add(groundBody);

        groundBody.position.copy(surfaceMesh.position);
        groundBody.quaternion.copy(surfaceMesh.quaternion);

        //ball body
        var ballShape = new CANNON.Sphere(1.6);
        ballBody = new CANNON.Body({mass: 2});
        ballBody.addShape(ballShape);
        ballBody.position.copy(ballMesh.position);
        world.add(ballBody);



    }

    function animate() {
        if (keyboard.pressed("left") && cube.position.x > -42) {
            cube.position.x -= 1;
        } else if (keyboard.pressed("right") && cube.position.x < 42) {
            cube.position.x += 1;
        }
        if (keyboard.pressed("A") && cube2.position.x > -42) {
            cube2.position.x -= 1;
        } else if (keyboard.pressed("D") && cube2.position.x < 42) {
            cube2.position.x += 1;
        }
        updatePhysics();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

    }

    function updatePhysics() {


        world.step(timeStep);


        ballMesh.position.copy(ballBody.position);
        ballMesh.quaternion.copy(ballBody.quaternion);
    }

</script>
</body>
</html>